
* 縦幅が変化しない場合の処理を作成する。

-- LineAveragingReducer_RatioAny の最適化

	縮小比率が1/2より大きい場合は、bodyCountが 0 か 1 で、今は2個分をまとめて処理する事によって高速化を図っているが、
	2個分が連続する傾向があるので、どの種類の2個分が何回継続するかを事前に調べてテーブル化するのはどうか？
	後の処理でループに出来る為、分岐を毎回しないで良いので高速に処理できるのでは無いか？
	
		// 0のみの場合
		// 1のみの場合
		// 先頭に 0 が 4個以上続く場合は、0の繰り返し回数のテーブル化。0の繰り返しの後には 1 が来る。最後だけ別。
		// 先頭が 0001 の場合は、0001の繰り返し回数のテーブル化。0001の繰り返しの後には 0 が来る。
		// 先頭が 001 の場合は、001の繰り返し回数のテーブル化。001の繰り返しの後には 0 が来る。
		// 先頭が 01001 の場合は、001の繰り返し回数のテーブル化。001の繰り返しの後には 01 が来る。
		// 先頭が 01 の場合は、01の繰り返し回数のテーブル化。01の繰り返しの後には 0 が来る。
		// 先頭が 10 の場合は、10の繰り返し回数のテーブル化。10の繰り返しの後には 1 が来る。
		// 先頭が 10110 の場合は、110の繰り返し回数のテーブル化。110の繰り返しの後には 10 が来る。
		// 先頭が 110 の場合は、110の繰り返し回数のテーブル化。110の繰り返しの後には 1 が来る。
		// 先頭に 1 が 3個以上続く場合は、1の繰り返し回数のテーブル化。1の繰り返しの後には 0 が来る。最後だけ別。
	
		0のみの場合を実装して、ループ中のswitchを無くして見たがそんなに速度が変わらない…。
		分岐１つくらいではそんなにクリティカルに処理速度が変わるということは無いようだ。
	
* Aboutのバージョン表示、初回にリソースから自動的にバージョンを取得して表示に使うようにする。

* ドラッグ＆ドロップに対応する。
	
	既に対応している。
	
	MRU更新処理を呼んでいなかった。

* 縮小表示する際に縦横比を保つオプションを付ける

* Windowの大きさが2048以下にしか対応していないので何とかする。

	MAX_WINDOW_WIDTH MAX_WINDOW_HEIGHT 定数の値を 2048 から 4096 に変更。

* 描画するかしないかの縮小比率の判断において縮小元の比率をチェックしていなかった問題を修正

----------------

高精度なデジタル積分処理を使うようにする。

	http://www.codeproject.com/KB/recipes/FastNumericalIntegration.aspx

ResampleImage 処理改良
	
	horizontal decimation をある程度やったら、vertical decimation するようにする。
	キャッシュにヒットするようにブロック化して処理する。
	（縦方向の縮小率が大きい場合は、ブロックのサイズが肥大するので意味が薄いけれど）
	
	横方向の縮小処理をSSEを使って最適化する。
	Lanczos2、Lanczos3

MIPMAPを実装する。

入出力32bit処理

	縦方向の縮小処理をスレッドで並列処理を行って最適化
		
		temporaryなbufferをthread分用意する必要がある。
		
			スレッドが大量に作られる環境も存在する。
			画像の高さが小さい場合に十分に確保されない場合があり得るので、事前に必要な容量を計算する。
		
		Class化しないと、分担呼び出しの為の情報取得等の体系化が煩わしい。
			AveragingReduce 関数自体を class化
		
		RatioAnyで、縦の比率が割り切れない場合でもきちんとthreadで分割して処理を行う。
		
		処理量を均等に分散する。
	
	極端に縮小比率が大きいとテンポラリなバッファが16bit精度の為にオーバーフローしてしまう事への対処。
	
		オーバーフローする可能性があるかどうかを事前に計算で調べる。
		一時バッファを各要素32bit精度にする？となると、floatが良いので、SSE2ではなくSSEでの処理になるか…。
		
			MIPMAPで回避する。
		
	SrcWidthが4の倍数で無いとassertに引っ掛かるけど、きちんとした横幅を渡さないとエラーになるので、対策する。
	
	現在処理していない端の部分まできちんと処理するように記述する。
	
		* 横 1 : N の縮小処理で右端にゴミが出てしまうので直す。
			
			LineAveragingReducer_Ratio1NX の横の余りの部分の処理記述。
		
			1pixelに満たない部分はどう処理するのか？
		
		端の1ピクセル分の占有率を再現する為にα値を変化させれるようにする。
			
			端のピクセルの占有率を計算する関数
			
			αビットマスクを渡してもらってそれで変更するバイトを計算するか？
			
	* LineAveragingReducer_RatioAny において、tailTargetRatios の読み込み2回を変形。
		
		32bit分まとめて行って、128bitレジスタの64ビットずつを占めるように変形。
	
	* 最適化した1.0.17の方が1.0.15より処理が遅くなっている。原因を調査。
		
		色々、__forceinlineとかとか…
		
	半透明合成に対応出来るようにAlphaChannelもきちんと縮小する版を作る。
	
		現状では問題があるのか？
		
		右端が問題がある。
		
	-- 最適化の為に、LineReducerに、読み込んで処理すると同時に16bit -> 8bitに変換して書き込む機能を付ける。

		○ AveragingReduce_Ratio1
		○ AveragingReduce_Ratio1NX
		× AveragingReduce_RatioAny
		
			自由比率の場合は、混ぜないといけないので大変だし、後で他と混ぜる為に格納しないといけないので無意味かも。
		
		どれだけ速度が変わるのか？
		
		temporaryに読み書きする処理を隠蔽化する必要がある。

	* 横 2 : 3 の縮小処理の特化版を作る

		書き出し 2 pixel 分のデータの為に、読み出し 3 pixel を必要とする。
		書き出し 8 pixel 読み出し 12 pixel 分を一気に処理

	-- 横 2 : 5 の縮小処理の特化版を作る

		書き出し 2 pixel 分のデータの為に、読み出し 5 pixel を必要とする。
		書き出し 8 pixel 読み出し 20 pixel 分を一気に処理

	-- 横 2 : 7 の縮小処理の特化版を作る

		書き出し 2 pixel 分のデータの為に、読み出し 7 pixel を必要とする。
		書き出し 8 pixel 読み出し 28 pixel 分を一気に処理
		
	-- 横 2 : 9 の縮小処理の特化版を作る

		書き出し 2 pixel 分のデータの為に、読み出し 9 pixel を必要とする。
		書き出し 8 pixel 読み出し 36 pixel 分を一気に処理

	横 2 : N の縮小処理の特化版を作る。

		書き出し 2 pixel で 128bitなので、書き出しを高速に行える。
		
	横 3 : 4 の縮小処理の特化版を作る。

		書き出し 3 pixel 分のデータの為に、読み出し 4 pixel を必要する。
		書き出し 6 pixel 読み出し 8 pixel 分を一気に処理

	横 3 : 5 の縮小処理の特化版を作る。

		書き出し 3 pixel 分のデータの為に、読み出し 5 pixel を必要する。
		書き出し 12 pixel 読み出し 20 pixel 分を一気に処理

	-- 横 3 : 7 の縮小処理の特化版を作る。

		書き出し 3 pixel 分のデータの為に、読み出し 7 pixel を必要する。
		書き出し 12 pixel 読み出し 28 pixel 分を一気に処理
		
	-- 横 3 : 8 の縮小処理の特化版を作る。

		書き出し 3 pixel 分のデータの為に、読み出し 8 pixel を必要する。
		書き出し 6 pixel 読み出し 16 pixel 分を一気に処理

	-- 横 3 : 10 の縮小処理の特化版を作る。

		書き出し 3 pixel 分のデータの為に、読み出し 10 pixel を必要する。
		書き出し 12 pixel 読み出し 40 pixel 分を一気に処理

	-- 横 M : 2N の縮小処理の特化版を作る。

		2M : 4N と捉えれば、

		書き出し 2 pixel で 128bitなので、書き出しを高速に行える。
		読み出し 4 pixel で 128bitなので、読み出しを高速に行える。

	-- 横 M : 4N の縮小処理の特化版を作る。

		M は 2以外。Nより小さい値。

		読み出し 4 pixel で 128bitなので、読み出しを高速に行える。

横方向の縮小処理 Lanczos2、縦方向面積平均法の縮小処理を作成する。
	
	縦方向の縮小処理は、面積平均法を使いたいので、別ファイルに分けるか。
	
	ラインの横方向縮小処理はInterface化したので十分対応可能。
	
Windowのどこに画像を表示するのか設定出来るようにする。（中央、左上、etc...）
	
設定ファイルを作って設定を保持する。
	
画像拡大にも対応する。
	
	縮小とは別に方式を設定出来るようにする。
	
	拡大では面積平均法は選べないようにする。

入力24bit 出力32bit処理
	
	巨大画像は32bitで持つと容量がもったいないので、24bitで持ちたくなる。

入力32bit 出力24bit処理
	
	必要性が薄いか。

入力YCbCrの対応
	
	色々な形式があるのでどれに対応するか？
	
	色差情報は sub samplingされてる事があるので…。
	
-- SSE4まで使って最適化

	出来れば一気に最適化したい。
	
	処理クラスを作ってtemplate指定か。出来ればnamespaceが良いけれど、template parameterでは無理なので。
		
		処理をまとめるという意味でclass化は望ましいのではないか？

-- ノイズ取り
	
---------------------------------

menu項目の自動生成

menuのIDとenumの相互変換

現在選択されているmenu項目に自動でcheckを付ける仕組み

UPDATE_ELEMENT(ID_RESAMPLINGFILTERS_BOX, UPDUI_MENUPOPUP)

WTLのMenu更新のメカニズムを使う場合には色々な記述が必要になる。

Menu項目を自動生成する場合は、どこまでWTLの枠組みを使うのかを考える必要がある。

MenuやMainFrame側では、Viewの都合は直接的には一切関与しないで済むようにする必要がある。

MIPMAP

---

ImageIO 

■構成

lib, dll に出来るlibraryを作成する。
利用するapplicationをbuildする度に再度compileをしなくても良いようにする。
利用する側では、headerのincludeを行う。

■機能

・対応画像フォーマット BMP, JPEG, TIFF, PNG に対応する。対応画像フォーマットを増やす事が容易な作りにする。
・読み込み範囲の指定、画像ファイルの一部だけを読み込む事が出来るようにする。
・画像をライン単位、もしくはブロック単位で読み取って処理を行う。全体を一度には処理しない。
・処理を途中で中断出来るようにする。

■原則
当ライブラリでのメモリの確保は最小限に留める。

